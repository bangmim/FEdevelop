html ( Hyper Text Markup Language)

-   페이지의 제목, 문단, 표, 이미지, 동영상 등 웹의 구조 담당

CSS(Cascading Style Sheets)

-   실제 화면에 표시되는 방법

JavaScript(데이터 중심의 사고)

-   컨텐츠를 바꾸고 움직이는 등 페이지를 동작시키는 동적 처리 담당

# 웹 앱의 동작방식

웹앱 == 홈페이지
사용자 -> 주소창에 페이지 주소 입력 (프로토콜(http or https)-> 최초 요청(request) -> 서버 -> 최초 응답(response): html -> 추가 요청 -> 서버 -> 추가 응답(css,js,jpg...)

웹 사이트를 개발하는 환경 == 로컬 환경
사용자가 사용하는 환경 == 서버

# 웹 표준 : 웹에서 사용되는 표준 기술이나 규칙

W3C의 표준화 제정 단계의 권고안(REC)에 해당하는 기술
크로스 브라우징 : 조금은 다르게 구동되는 여러 브라우저에서 동일한 사용자 경험(같은 화면, 같은 동작 등)을 줄 수 있도록 제작하는 기술 ,방법
브라우저 종류 : 크롬, 엣지, 파이어폭스, 오페라, 스윙, 웨일, IE, 사파리..
크로스 브라우징 이슈는 점점 줄어드는 편

# 웹 이미지 : 비트맵과 백터

-   비트맵(픽셀이 모여 만들어진 정보의 집합) : jpeg, gif, png ...
    -   정교하고 다양한 색상을 자연스럽게 표현.
    -   확대/축소 시 계단현상, 품질 저하
-   벡터(점, 선, 면의 위치(좌표), 색상 등 수학적 정보의 형태로 이루어진 이미지) : svg
    -   확대/축소에서 자유로움, 용량 변화 없음
    -   정교한 이미지(인물, 풍경 사진 같은)를 표현하기 어려움

# 특수 문자 용어

'`' Backtick, Grave: 백틱, 그레이브
~ Tilde: 틸트, 물결 표시
! Exclamation mark: 엑스클러메이션, 느낌표
@ At sign: 앳, 골뱅이
'#' Sharp, Number sign : 샵, 넘버, 우물 정
$ Dollar sign: 달러
'%' Percent sign: 퍼센트
^ Caret: 캐럿 (~이상)
& Ampersand: 엠퍼센드
'\*' Asterick : 에스터리스크, 별표
'-' Hyphen,Dash : 하이픈, 대시, 마이너스
'\_' Underscore, Low dash: 언더스코어, 로대시, 밑줄
= Equal sign: 이퀄, 동등
" Quotation mark:쿼테이션, 큰 따옴표
' Apostrophe: 아포스트로피, 작은 따옴표
: Colon: 콜론
; Semicolon : 세미콜론
, Comma : 콤마, 쉽표
. Period, Dot: 피리어드, 닷, 점, 마침표
? Question mark : 퀘스쳔, 물음표
/ Slash : 슬래시
| Vertical bar : 버티컬 바
\ Backslash : 백슬래시, 역 슬래시
() Parenthesis : 퍼렌서시스, 소괄호, 괄호
{} Brace : 브레이스, 중괄호
[] Bracket : 브래킷, 대괄호
<> Angle Bracket : 앵글브래킷, 꺽쇠괄호

# 오픈소스 라이선스

-   Apache License : 개인적/상업적 이용, 배포, 수정, 특허 신청 가능
-   MIT License : 매사추세츠공과대학(MIT)에서 소프트웨어 학생들을 위해 개발한 라이선스, 개인 소스에 이 라이선스를 사용하고 있다는 표시만 지켜주면 되며, 나머지 사용에 대한 제약은 없음
    프로젝트 소스 코드에 외부에서 가져온 오픈소스의 라이선스 내용만 정확히 명시하면 충분.
    대부분 프로젝트에서는 자동으로 오픈소스가 같이 빌드되기 때문에 따로 관리할 필요 없음
-   BSD
-   Beerware
    무조건 무료인 라이선스는 없다. 항상 라이선스를 확인하는 습관을 가지자!


# 웹(Web)
HTTP (HyperText Transfer Protocol)
웹상에서 데이터를 주고받기 위한 프로토콜
웹 문서를 주고받기 위하여 사용할 수 있다.
HTTP는 상태를 저장하지 않는다(Stateless)
클라이언트는 HTTP로 서버에 연결한 뒤에, 응답을 받으면 연결을 끊어버린다.
-> 서버 입장에서 접속 유지에 대한 요구가 적어, 불특정 다수를 대상으로 하는 서비스에 적합하다.
예시로, 상품 확인 -> 장바구니 -> 결제의 과정이 시스템적으로 상태 정보로 기록되지 않는다.
하지만, 세션(Session)을 이용해 원하는 기능이 수행되도록 한다.
Keep Alive 기능 : 하나의 웹 사이트에 방문하면 대개 수십 개의 파일(CSS, 이미지, HTML, JS)를 제공한다.
TCP 통신 과정에서 연결 수행/연결 해제 과정에서 리소스가 많이 소요된다.
keep-alive는 이런 파일을 하나씩 받기 위하여 매번 연결을 맺고 끊는 것을 방지한다.

# REST API
REST(Representational State Transfer) 등장 배경
HTTP는 다양한 HTTP 메서드(GET, POST, PUT, DELETE 등)를 지원한다.
실제로 서버가 HTTP메서드를 기존 설명에 맞게 사용하지 않더라도, 프로그램 개발은 가능하다.
기준이 되는 아키텍처로 REST를 채택할 수 있다.
특정한 자원(resource)에 대하여, 자원의 상태에 대한 정보를 주고받는 개발 방식
<구성요소>
- 자원(Resource): URI이용
- 행위(verb): HTTP메서드 이용
- 표현(representation): 페이로드(payload)이용

API(Application Programmning Interface) : 프로그램이 상호작용하기 위한 인터페이스
REST API : REST 아키텍처를 따르는 API
REST API 호출 : REST 방식을 따르고 있는 서버에 특정한 요청(request)를 전송하는 행위

목킹(mocking): 어떠한 기능이 있는것처럼 흉내내어 구현한 것을 의미
클라이언트 개발을 위해 간단히 서버 기능을 테스트할 때 사용
처음부터 모든 서버 기능을 개발하고, 클라이언트 개발을 시작하면 개발 일정에 지연이 생길 수 있다.

# OAuth(오어쓰)
구글 로그인 기능을 떠올리면 간단하다
웹 서버에 구글 비밀번호를 제공하지 않고도, 구글 계정의 일부 접근 권한을 부여할 수 있다.
실제로 많은 애플리케이션에서 SNS(Google, Facebook 등) 간편 로그인 기능을 제공한다.
Access Token 이용하기
사용자가 설정한 권한에 대해서만 구글 정보에 접근할 수 있도록

<OAuth 2.0 구성요소>
- Resource Owner : 특정한 서비스를 사용하려고 하는 사용자. 대부분 개인정보(Resource)의 소유자(개인)을 의미
- Client : 특정한 개인 혹은 회사가 만든 서비스를 의미
일반적인 웹/앱 서버를 의미하지만 ,Client라고 부른다.
- Resource Server : 사용자의 개인정보를 가지고 있는 서버를 의미
Client는 Access Token을 Resource Server에 보내서 사용자의 개인정보를 얻는다.
- Authorization Server : 실질적으로 권한 부여 기능을 담당하는 서버. 사용자는 자신의 SNS계정 정보(ID, PW)를 넘겨 Authorization Code를 받는다. Client는 사용자로부터 받은 Authorization Code를 넘겨 Access Token을 받는다.

# JWT(JSON Web Token)
JSON 형식(Format) : Json은 데이터를 주고받기 위해 사용하는 경량의 데이터 형식 중 하나다.
JSON 형식에서는 키와 값의 쌍으로 이루어진 데이터 객체를 사용한다.

JWT는 세가지 구성요소(Header, Payload, Signature)를 가진다.
사용자가 인증을 수행하면, 서버는 다음의 정보를 가진 JWT 토큰을 발급한다. 
- Header: 사용할 해시 알고리즘 등의 메타 정보를 포함
- Payload : 키와 값 형식으로 이루어진 정보(claim)의 구성
- Signature: 헤더+페이로드+키 정보를 해싱하여 client에게 함께 전달한다.
xxxx[Header].yyyy[Payload].zzzz[Signature]

JWT 를 이용한 인증
- 나중에 사용자(client)는 자신이 받았던 JWT 토큰을 다시 서버에 전달한다
- 서버는 (헤더+ 페이로드+ 서버 내에 있는 키(key))를 해싱한 값이 사용자로부터 전달받은 것과 일치하는지 체크
- 이 과정에서 서버가 가지고 있는 비밀키를 사용한다.

JWT 인증 원리
- 사용자는 서버가 처음에 부여했던 권한만큼의 작업을 요청할 수 있다.
- 데이터를 변경하면 해시 값이 변경되므로, 악의적인 공격자가 Payload를 수정하는 것이 불가능하다.
- 예를 들어 사용자의 등급이 1,2,3,4,5 일 때 5등급의 사람이 1등급으로 Payload를 변경해 보냈다고 해보자. 이 경우, 서버의 키를 모르므로, 서명 값이 일치하지 않아 서버가 위조 여부를 알 수 있다.

[장점]
-세션 기반 인증방식에 비해 서버가 DB에 세션 정보를 가지고 있을 필요가 없다.
-각 해시 값이 어떤 Header 와 Payload를 가지는지 일일이 서버 DB에서 저장할 이유가 없다.
-> 서버에서 상태 정보를 저장하지 않아도 되므로, 무상태성이 유지된다.
-토큰 기반이므로, 서로 다른 웹 서버에 대해서도 동작할 수 있다.

[단점]
-세션이 비하여 토큰 자체의 데이터 길이가 길다
-페이로드는 암호화되지 않으므로, 중요한 정보를 담기 적절하지 않을 수 있다
-토큰을 탈취당하는 경우 보안상의 문제가 발생할 수 있다.(때문에 토큰에 사용 기한을 부여한다)